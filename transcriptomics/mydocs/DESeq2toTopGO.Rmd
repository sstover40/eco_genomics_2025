---
title: "DESeq2toTopGO"
output: html_document
date: "2025-10-23"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#to set our working dir
knitr::opts_knit$set(root.dir = "/gpfs1/home/s/s/sstover/projects/eco_genomics_2025/transcriptomics/mydata")
```

Importing the data from DESeq2 to generate the results that we need for testing functional enrichment
```{r}
## Import the libraries that we're likely to need in this session

library(DESeq2)
library(dplyr)
library(tibble)
library(topGO)
library(GO.db)
library(ggplot2)
library(scales) 
 
# Import the counts matrix
countsTable <- read.table("counts_matrix.txt", header=TRUE, row.names=1)
dim(countsTable)

countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
# Corrects the column names to match between the metadata table and the counts matrix.
colnames(countsTableRound) <- substr(colnames(countsTableRound), start=1, stop = 4)

#import the sample description table
conds <- read.delim("metadata.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)


#### Create a DESeq object and define the experimental design here with the tilda

dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds, 
                              design= ~ generation + line)

dim(dds)

# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds) 
# How many transcripts have at least 15 reads (a.k.a counts) in 75% of the samples

# Run the DESeq model to test for differential gene expression

dds$line <- relevel(dds$line, ref = "control")
dds$generation <- relevel(dds$generation, ref = "G1")

dds$group <- factor(paste0(dds$line, dds$generation))
design(dds) <- ~ group
dds <- DESeq(dds)
resultsNames(dds)


#Gen1
resG1_CvT <- results(dds, contrast=c("group","controlG1","treatmentG1"), alpha = 0.05)
resG1_CvT <- resG1_CvT[order(resG1_CvT$padj),] #sort
resG1_CvT <- resG1_CvT[!is.na(resG1_CvT$padj),]

#Gen2
resG2_CvT <- results(dds, contrast=c("group","controlG2","treatmentG2"), alpha = 0.05)
resG2_CvT <- resG2_CvT[order(resG2_CvT$padj),] #sort
resG2_CvT <- resG2_CvT[!is.na(resG2_CvT$padj),]

#Gen3
resG3_CvT <- results(dds, contrast=c("group","controlG3","treatmentG3"), alpha = 0.05)
resG3_CvT <- resG3_CvT[order(resG3_CvT$padj),] #sort
resG3_CvT <- resG3_CvT[!is.na(resG3_CvT$padj),]

#Gen4
resG4_CvT <- results(dds, contrast=c("group","controlG4","treatmentG4"), alpha = 0.05)
resG4_CvT <- resG4_CvT[order(resG4_CvT$padj),] #sort
resG4_CvT <- resG4_CvT[!is.na(resG4_CvT$padj),]
```

Before we jump in, what do the distributions of our results look like? looking at the results tables since they are ultimately going into the functional enrichment analysis 
```{r}
library(ggplot2)
library(ggpubr)

# Convert results to data frame and clean
res_df <- as.data.frame(resG1_CvT)
res_df <- res_df[!is.na(res_df$padj), ]

# Calculate and add -log10(padj)
res_df$negLog10Padj <- -log10(res_df$padj)

# Panel 1: padj distribution
p1 <- ggplot(res_df, aes(x = padj)) +
  geom_histogram(bins = 50, fill = "skyblue3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("Adjusted p-values (padj)") +
  xlab("padj") +
  ylab("Count")

# Panel 2: -log10(padj)
p2 <- ggplot(res_df, aes(x = negLog10Padj)) +
  geom_histogram(bins = 50, fill = "tomato3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("-log10(padj)") +
  xlab("-log10(padj)") +
  ylab("Count")

# Panel 3: Wald Statistic
p3 <- ggplot(res_df, aes(x = stat)) +
  geom_histogram(bins = 50, fill = "seagreen3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("Wald Statistic") +
  xlab("stat") +
  ylab("Count")

# Combine vertically with ggpubr
combined_plot <- ggarrange(
  p1, p2, p3,
  ncol = 1, nrow = 3,
  labels = c("A", "B", "C"),  # optional panel labels
  align = "v",                # vertical alignment
  common.legend = FALSE
)

# Show combined plot
combined_plot
```

And what are the relationships between these metrics?
```{r}
# Panel D: Wald statistic vs -log10(padj) scatter 
p4 <- ggplot(res_df, aes(x = pvalue, y = negLog10Padj)) +
  geom_point(alpha = 0.4, color = "yellow4") + ylim(c(0,5)) +
  theme_minimal(base_size = 8) +
  ggtitle("P-value vs -log10(padj)") +
  xlab("P-value") +
  ylab("-log10(padj)") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")

# Panel E: Wald statistic vs -log10(padj) scatter 
p5 <- ggplot(res_df, aes(x = stat, y = negLog10Padj)) +
  geom_point(alpha = 0.4, color = "purple4") + ylim(c(0,5)) +
  theme_minimal(base_size = 8) +
  ggtitle("Wald Statistic vs -log10(padj)") +
  xlab("Wald statistic") +
  ylab("-log10(padj)") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")


combined_plot <- ggarrange(
  p4, p5,
  ncol = 2, nrow = 1,
  align = "h"
)

# Show combined plot
combined_plot
```

Let’s make a density plot with a rugplot below to understand what we’re testing in a functional enrichment test.
The rug plot can tell us how many genes are driving that tail distributions that are driving the density plot tail 
This is another way to look at the data that is in the plot above.
```{r}
ggplot(res_df, aes(x = negLog10Padj)) +
  geom_density(fill = "lightblue", color = "blue", alpha = 0.5, linewidth = 1) + xlim(c(0,5)) +
  geom_rug(sides = "b", color = "gray30", alpha = 0.5) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed", color = "red") +
  theme_minimal(base_size = 8) +
  xlab(expression(-log[10](padj))) +
  ylab("Density") +
  ggtitle(expression("Density of " * -log[10](padj)))
```

Run TopGO!

You’ll need the Genes_GO_terms_output.tsv file that maps each gene to GO categories for the transcriptome of our species. This can be found in: /gpfs1/cl/ecogen/pbio6800/Transcriptomics/enrichment. You can cp it to your /mydata directory.
Let’s start with DESeq2 results object for Gen 2, since we know it has the most differentially expressed genes
```{r}
library(topGO)
library(GO.db)

# Convert to data frame
res_G2_df <- as.data.frame(resG2_CvT)

# Add geneID column from rownames
res_G2_df$geneID <- rownames(res_G2_df)
res_G2_df <- res_G2_df[, c("geneID", setdiff(names(res_G2_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G2_GO <- res_G2_df[res_G2_df$geneID %in% tonsa_go$geneID, ]

# Identify significant DEGs 
res_G2_GO_sig <- subset(res_G2_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
tonsa_stat <- merge(res_G2_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G2 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,    #this is the minimum GO category size. can play with this
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen2")
topGO_plot
```

How about for Generation 1?!

Can you run the same analysis for generation 1? Can you make a figure of two side-by-side plots for Gen 1 and Gen 2? How about all four contrasts?
Can we output the enrichment results from TopGO and try REViGO like what was used in the paper we discuss in class today.
```{r}
# Select only the columns REVIGO needs
revigo_input <- filtered_GO_results[, c("GO.ID", "classicFisher")] #this table will be used to filter 

sigRes <- revigo_input[as.numeric(revigo_input$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes, file = "topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```
