---
title: "transcriptomics_HW_code"
output: html_document
date: "2025-11-08"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#to set our working dir
knitr::opts_knit$set(root.dir = "/gpfs1/home/s/s/sstover/projects/eco_genomics_2025/transcriptomics/mydata")
```

###Main Question: How do the functional groups of DEGs vary from generation 1 to generation 4?
```{r}
## Import the libraries that we're likely to need in this session

library(DESeq2)
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(ggpubr)
library(vsn)  
library("pheatmap")
library("vsn")

####################################################

### Import our data

####################################################

# Import the counts matrix
countsTable <- read.table("counts_matrix.txt", header=TRUE, row.names=1)
head(countsTable)
dim(countsTable)
```
```{r}
countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
head(countsTableRound)
```
```{r}
#import the sample description table
conds <- read.delim("metadata.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)
head(conds)
```

Define our model and create a DESeq2 object
```{r}
####################################################

### Start working with DESeq2!

####################################################

#### Create a DESeq object and define the experimental design here with the tilda

#corrects the column names to match btwn the metadata table and the counts matrix 
colnames(countsTableRound) <- substr(colnames(countsTableRound), start=1, stop=4)

dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds, 
                              design= ~ generation + line)

dim(dds)

# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds) 

# How many transcripts have at least 15 reads (a.k.a counts) in 75% of the samples

# Run the DESeq model to test for differential gene expression
dds <- DESeq(dds)

# List the results you've generated
resultsNames(dds)
# Copy the results names 
```

PCA plot to visualize gene expression variation among treatment Generations
```{r}
####################################################

### Check the quality of the data by sample clustering and visualization

####################################################

# The goal of transformation "is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low."

library("pheatmap")
library("vsn")

# this gives log2(n + 1)
ntd <- normTransform(dds)
meanSdPlot(assay(ntd))

# Variance stabilizing transformation
vsd <- vst(dds, blind=FALSE)
meanSdPlot(assay(vsd))


sampleDists <- dist(t(assay(vsd)))

library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$line, vsd$generation, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

# Note any outliers

###############################################################

# PCA to visualize global gene expression patterns

# first transform the data for plotting using variance stabilization
vsd <- vst(dds, blind=FALSE)

pcaData <- plotPCA(vsd, intgroup=c("line","generation"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData,"percentVar"))

#filtering for just treatment 
pcaData_filt <- pcaData %>%
  filter(line == "treatment")

ggplot(pcaData_filt, aes(PC1, PC2)) +
  geom_point(size=5, stroke = 1, aes(fill=line, shape=generation, alpha = generation)) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  scale_shape_manual(values=c(21,22,23,24), labels = c("G1", "G2","G3", "G4"))+
  #scale_shape_manual(values=c(21,22,23,24) -> circle, square, diamond, triangle
  scale_fill_manual(values=c("#CC3333", '#6699CC'), labels = c("Treatment", "Control"))+
  scale_alpha_manual(values = c(1.0, 0.8, 0.7, 0.3), guide = "none") +
  theme_bw() +
  theme(legend.position = "none") +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 3))+
  theme(text = element_text(size = 20)) +
  theme(legend.title = element_blank())
```
looks like most of the variance (PC1) is between G1 and the other generations which is what I would expect. PC2 seems to vary between replicates but there may be a slight pattern of G1 and G3 being more spread out while G2 and G4 cluster....


```{r}
dds$line <- relevel(dds$line, ref = "control")
dds$generation <- relevel(dds$generation, ref = "G1")


dds$group <- factor(paste0(dds$line, dds$generation))
design(dds) <- ~ group
dds <- DESeq(dds)
resultsNames(dds)
```


Compare each generation to every other generation for treatment
1. G1 and G2 
```{r}
#comparison
resT_G1v2 <- results(dds, contrast=c("group","treatmentG1","treatmentG2"), alpha = 0.05) #alpha = significance value 

summary(resT_G1v2)

#differentiate up reg and down reg DEGs
up_G1v2 <- sum(resT_G1v2$padj < 0.05 & resT_G1v2$log2FoldChange > 0, na.rm=TRUE)
down_G1v2 <- sum(resT_G1v2$padj < 0.05 & resT_G1v2$log2FoldChange < 0, na.rm=TRUE)
```
2. G1 and G3
```{r}
resT_G1v3 <- results(dds, contrast=c("group","treatmentG1","treatmentG3"), alpha = 0.05) #alpha = significance value 

summary(resT_G1v3)

#differentiate up reg and down reg DEGs
up_G1v3 <- sum(resT_G1v3$padj < 0.05 & resT_G1v3$log2FoldChange > 0, na.rm=TRUE)
down_G1v3 <- sum(resT_G1v3$padj < 0.05 & resT_G1v3$log2FoldChange < 0, na.rm=TRUE)
```
3. G1 and G4
```{r}
resT_G1v4 <- results(dds, contrast=c("group","treatmentG1","treatmentG4"), alpha = 0.05) #alpha = significance value 

summary(resT_G1v4)

#differentiate up reg and down reg DEGs
up_G1v4 <- sum(resT_G1v4$padj < 0.05 & resT_G1v4$log2FoldChange > 0, na.rm=TRUE)
down_G1v4 <- sum(resT_G1v4$padj < 0.05 & resT_G1v4$log2FoldChange < 0, na.rm=TRUE)
```
4. G2 and G3
```{r}
resT_G2v3 <- results(dds, contrast=c("group","treatmentG2","treatmentG3"), alpha = 0.05) #alpha = significance value 

summary(resT_G2v3)

#differentiate up reg and down reg DEGs
up_G2v3 <- sum(resT_G2v3$padj < 0.05 & resT_G2v3$log2FoldChange > 0, na.rm=TRUE)
down_G2v3 <- sum(resT_G2v3$padj < 0.05 & resT_G2v3$log2FoldChange < 0, na.rm=TRUE)
```
5. G2 and G4
```{r}
resT_G2v4 <- results(dds, contrast=c("group","treatmentG2","treatmentG4"), alpha = 0.05) #alpha = significance value 

summary(resT_G2v4)

#differentiate up reg and down reg DEGs
up_G2v4 <- sum(resT_G2v4$padj < 0.05 & resT_G2v4$log2FoldChange > 0, na.rm=TRUE)
down_G2v4 <- sum(resT_G2v4$padj < 0.05 & resT_G2v4$log2FoldChange < 0, na.rm=TRUE)
```
6. G3 and G4 
```{r}
resT_G3v4 <- results(dds, contrast=c("group","treatmentG3","treatmentG4"), alpha = 0.05) #alpha = significance value 

summary(resT_G3v4)

#differentiate up reg and down reg DEGs
up_G3v4 <- sum(resT_G3v4$padj < 0.05 & resT_G3v4$log2FoldChange > 0, na.rm=TRUE)
down_G3v4 <- sum(resT_G3v4$padj < 0.05 & resT_G3v4$log2FoldChange < 0, na.rm=TRUE)
```
Question: What is the relationship between LFC and significance of DGE? 
```{r}

# Make a dataframe
res_df <- as.data.frame(resT_G1v2)

# Remove NAs
res_df <- res_df[!is.na(res_df$padj), ]

# Add significance column for color mapping
res_df$significance <- "Not Sig"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange > 0] <- "Up"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange < 0] <- "Down"

#using the new "significance" column to color things 
ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = significance)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = c("Down" = "red", "Up" = "blue", "Not Sig" = "grey")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(
    title = "Volcano Plot: Treatment G1 vs. G2",
    x = expression(log[2]~Fold~Change),
    y = expression(-log[10]~Adjusted~p~value)
  ) +
  theme_bw(base_size = 16) +
  theme(legend.title = element_blank())
```

Make a heatmap of G1 vs G2 sig genes and how they change across generations

Question: How does gene expression change across generations for the genes that are differentially expressed from G1 to G2
```{r}
sig_genes_G1v2 <- rownames(resT_G1v2[which(resT_G1v2$padj < 0.05 & !is.na(resT_G1v2$padj)), ])

# Combine into a data frame
lfc_mat <- data.frame(
  Gen1v2 = resT_G1v2[sig_genes_G1v2, "log2FoldChange"],
  Gen1v3 = resT_G1v3[sig_genes_G1v2, "log2FoldChange"],
  Gen1v4 = resT_G1v4[sig_genes_G1v2, "log2FoldChange"]
#  Gen4 = resG4_CvT[sig_genes_G1, "log2FoldChange"]
)

# Remove any rows with missing values (some genes may not be in all result tables, will mess with values)
lfc_mat <- na.omit(lfc_mat)

pheatmap(lfc_mat,
         scale = "row",             # scales each gene’s LFCs across generations
         color = colorRampPalette(c("blue", "white", "red"))(50),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         show_rownames = FALSE,
         main = "LFC of Sig Genes in Gen 1 across Generations")

```
G2 and G4 group together here...

Heat map exploring DEGs between all generations
```{r}

#data frame to store up and down DEGs for each comparison 
deg_summary <- data.frame(
  comparison = c("G1vG2","G1vG3","G1vG4","G2vG3","G2vG4","G3vG4"),
  up = c(up_G1v2, up_G1v3, up_G1v4, up_G2v3, up_G2v4, up_G3v4),
  down = c(down_G1v2, down_G1v3, down_G1v4, down_G2v3, down_G2v4, down_G3v4)
)

#making a matrix for up and down counts 
gens <- c("G1","G2","G3","G4")
up_mat <- matrix(0, nrow=4, ncol=4, dimnames=list(gens, gens))
down_mat <- matrix(0, nrow=4, ncol=4, dimnames=list(gens, gens))

#filling in the matrix:
up_mat["G1","G2"] <- up_G1v2
up_mat["G1","G3"] <- up_G1v3
up_mat["G1","G4"] <- up_G1v4
up_mat["G2","G3"] <- up_G2v3
up_mat["G2","G4"] <- up_G2v4
up_mat["G3","G4"] <- up_G3v4

#downregulated matrix on the opposite triangle
down_mat["G2","G1"] <- down_G1v2
down_mat["G3","G1"] <- down_G1v3
down_mat["G4","G1"] <- down_G1v4
down_mat["G3","G2"] <- down_G2v3
down_mat["G4","G2"] <- down_G2v4
down_mat["G4","G3"] <- down_G3v4


# Convert matrices to data frames and rename count column
up_df <- as.data.frame(as.table(up_mat))
colnames(up_df)[3] <- "value"
down_df <- as.data.frame(as.table(down_mat))
colnames(down_df)[3] <- "value"

# Define generation order
gens <- c("G1","G2","G3","G4")

# Set factor levels for x and y axes
up_df$Var1 <- factor(up_df$Var1, levels = gens)
up_df$Var2 <- factor(up_df$Var2, levels = rev(gens))  # reverse for top-to-bottom y-axis
down_df$Var1 <- factor(down_df$Var1, levels = gens)
down_df$Var2 <- factor(down_df$Var2, levels = rev(gens))

# Filter upper and lower triangle, exclude diagonal
up_tile <- up_df %>% filter(as.numeric(Var1) < (length(gens)+1 - as.numeric(Var2)))   # upper triangle
down_tile <- down_df %>% filter(as.numeric(Var1) > (length(gens)+1 - as.numeric(Var2))) # lower triangle

# Plot heatmap
ggplot() +
  # Upper triangle = upregulated
  geom_tile(data = up_tile, aes(x=Var1, y=Var2, fill=value), color="white") +
  # Lower triangle = downregulated
  geom_tile(data = down_tile, aes(x=Var1, y=Var2, fill=-value), color="white") +
  # Fill gradient: blue = down, white = 0, red = up
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, name="DEG count") +
  # Add count labels
  geom_text(data = up_tile, aes(x=Var1, y=Var2, label=value), color="black", size=4) +
  geom_text(data = down_tile, aes(x=Var1, y=Var2, label=value), color="black", size=4) +
  # Theme
  theme_minimal() +
  coord_fixed() +
  labs(x="Generation", y="Generation") +
  theme(axis.text.x = element_text(angle=45, hjust=1))

```
G2 and G4 have very little difference in DEGs but G3 and G4 are less similar - what is going on in G3????? 
G1 and G4 have the most DEGs (expected)
G1vG2 and G1vG3 are similar in # of DEGs 
G2vG3 and G3vG4 are also around the same 


###--> Compare Enrichment in G1v4,G2v4,G3v4
##TOPGO ANALYSIS  

Importing the data from DESeq2 to generate the results that we need for testing functional enrichment
```{r}
## Import the libraries that we're likely to need in this session
library(tibble)
library(topGO)
library(GO.db)
library(scales) 
```

Before we jump in, what do the distributions of our results look like? looking at the results tables since they are ultimately going into the functional enrichment analysis 
```{r}
library(ggplot2)
library(ggpubr)

# Convert results to data frame and clean (looking at G1v4 here as an example)
res_df <- as.data.frame(resT_G1v4)
res_df <- res_df[!is.na(res_df$padj), ]

# Calculate and add -log10(padj)
res_df$negLog10Padj <- -log10(res_df$padj)

# Panel 1: padj distribution
p1 <- ggplot(res_df, aes(x = padj)) +
  geom_histogram(bins = 50, fill = "skyblue3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("Adjusted p-values (padj)") +
  xlab("padj") +
  ylab("Count")

# Panel 2: -log10(padj)
p2 <- ggplot(res_df, aes(x = negLog10Padj)) +
  geom_histogram(bins = 50, fill = "tomato3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("-log10(padj)") +
  xlab("-log10(padj)") +
  ylab("Count")

# Panel 3: Wald Statistic
p3 <- ggplot(res_df, aes(x = stat)) +
  geom_histogram(bins = 50, fill = "seagreen3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("Wald Statistic") +
  xlab("stat") +
  ylab("Count")

# Combine vertically with ggpubr
combined_plot <- ggarrange(
  p1, p2, p3,
  ncol = 1, nrow = 3,
  labels = c("A", "B", "C"),  # optional panel labels
  align = "v",                # vertical alignment
  common.legend = FALSE
)

# Show combined plot
combined_plot
```

And what are the relationships between these metrics?
```{r}
# Panel D: Wald statistic vs -log10(padj) scatter 
p4 <- ggplot(res_df, aes(x = pvalue, y = negLog10Padj)) +
  geom_point(alpha = 0.4, color = "yellow4") + ylim(c(0,5)) +
  theme_minimal(base_size = 8) +
  ggtitle("P-value vs -log10(padj)") +
  xlab("P-value") +
  ylab("-log10(padj)") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")

# Panel E: Wald statistic vs -log10(padj) scatter 
p5 <- ggplot(res_df, aes(x = stat, y = negLog10Padj)) +
  geom_point(alpha = 0.4, color = "purple4") + ylim(c(0,5)) +
  theme_minimal(base_size = 8) +
  ggtitle("Wald Statistic vs -log10(padj)") +
  xlab("Wald statistic") +
  ylab("-log10(padj)") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")


combined_plot <- ggarrange(
  p4, p5,
  ncol = 2, nrow = 1,
  align = "h"
)

# Show combined plot
combined_plot
```

Let’s make a density plot with a rugplot below to understand what we’re testing in a functional enrichment test.
The rug plot can tell us how many genes are driving that tail distributions that are driving the density plot tail 
This is another way to look at the data that is in the plot above.
```{r}
ggplot(res_df, aes(x = negLog10Padj)) +
  geom_density(fill = "lightblue", color = "blue", alpha = 0.5, linewidth = 1) + xlim(c(0,5)) +
  geom_rug(sides = "b", color = "gray30", alpha = 0.5) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed", color = "red") +
  theme_minimal(base_size = 8) +
  xlab(expression(-log[10](padj))) +
  ylab("Density") +
  ggtitle(expression("Density of " * -log[10](padj)))
```

Run TopGO!

You’ll need the Genes_GO_terms_output.tsv file that maps each gene to GO categories for the transcriptome of our species. This can be found in: /gpfs1/cl/ecogen/pbio6800/Transcriptomics/enrichment. You can cp it to your /mydata directory.
Let’s start with DESeq2 results object for Gen 2, since we know it has the most differentially expressed genes
```{r}
library(topGO)
library(GO.db)
library(patchwork)

# Convert to data frame
res_G1v4_df <- as.data.frame(resT_G1v4)
res_G2v4_df <- as.data.frame(resT_G2v4)
res_G3v4_df <- as.data.frame(resT_G3v4)


# Add geneID column from rownames
res_G1v4_df$geneID <- rownames(res_G1v4_df)
res_G1v4_df <- res_G1v4_df[, c("geneID", setdiff(names(res_G1v4_df), "geneID"))]

res_G2v4_df$geneID <- rownames(res_G2v4_df)
res_G2v4_df <- res_G2v4_df[, c("geneID", setdiff(names(res_G2v4_df), "geneID"))]

res_G3v4_df$geneID <- rownames(res_G3v4_df)
res_G3v4_df <- res_G3v4_df[, c("geneID", setdiff(names(res_G3v4_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G1v4_GO <- res_G1v4_df[res_G1v4_df$geneID %in% tonsa_go$geneID, ]

res_G2v4_GO <- res_G2v4_df[res_G2v4_df$geneID %in% tonsa_go$geneID, ]

res_G3v4_GO <- res_G3v4_df[res_G3v4_df$geneID %in% tonsa_go$geneID, ]

# Identify significant DEGs 
res_G1v4_GO_sig <- subset(res_G1v4_GO, padj < 0.05 & abs(log2FoldChange) > 1)

res_G2v4_GO_sig <- subset(res_G2v4_GO, padj < 0.05 & abs(log2FoldChange) > 1)

res_G3v4_GO_sig <- subset(res_G3v4_GO, padj < 0.05 & abs(log2FoldChange) > 1)

# Merge with GO annotations
tonsa_stat1v4 <- merge(res_G1v4_GO_sig, tonsa_go, by = "geneID")

tonsa_stat2v4 <- merge(res_G2v4_GO_sig, tonsa_go, by = "geneID")

tonsa_stat3v4 <- merge(res_G3v4_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList1v4 <- setNames(as.integer(all_genes %in% tonsa_stat1v4$geneID), all_genes)

geneList2v4 <- setNames(as.integer(all_genes %in% tonsa_stat2v4$geneID), all_genes)

geneList3v4 <- setNames(as.integer(all_genes %in% tonsa_stat3v4$geneID), all_genes)

#Build TopGO pipeline 
GOdata1v4 <- new("topGOdata",
              description = "G1v4 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList1v4,
              geneSel = function(x) x == 1,
              nodeSize = 5,    #this is the minimum GO category size. can play with this
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

GOdata2v4 <- new("topGOdata",
              description = "G2v4 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList2v4,
              geneSel = function(x) x == 1,
              nodeSize = 5,    #this is the minimum GO category size. can play with this
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

GOdata3v4 <- new("topGOdata",
              description = "G3v4 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList3v4,
              geneSel = function(x) x == 1,
              nodeSize = 5,    #this is the minimum GO category size. can play with this
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result1v4 <- runTest(GOdata1v4, algorithm = "parentChild", statistic = "fisher")

result2v4 <- runTest(GOdata2v4, algorithm = "parentChild", statistic = "fisher")

result3v4 <- runTest(GOdata3v4, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
res_table1v4 <- GenTable(GOdata1v4, classicFisher = result1v4,
                      topNodes = length(usedGO(GOdata1v4))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

res_table2v4 <- GenTable(GOdata2v4, classicFisher = result2v4,
                      topNodes = length(usedGO(GOdata2v4))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

res_table3v4 <- GenTable(GOdata3v4, classicFisher = result3v4,
                      topNodes = length(usedGO(GOdata3v4))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_resultsG1v4 <- res_table1v4 %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)

filtered_GO_resultsG2v4 <- res_table2v4 %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)

filtered_GO_resultsG3v4 <- res_table3v4 %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


#reusable TopGO plot 
TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate three plots
plotG1v4 <- TopGO_plot(filtered_GO_resultsG1v4, "G1 vs G4")
plotG2v4 <- TopGO_plot(filtered_GO_resultsG2v4, "G2 vs G4")
plotG3v4 <- TopGO_plot(filtered_GO_resultsG3v4, "G3 vs G4")

# Combine into 3-panel figure
combined_plot <- (plotG1v4 | plotG2v4 | plotG3v4) + plot_layout(guides = "collect")
combined_plot
```

output the enrichment results from TopGO and try REViGO like what was used in the paper we discuss in class today.
```{r}
# Select only the columns REVIGO needs
revigo_input <- filtered_GO_results[, c("GO.ID", "classicFisher")] #this table will be used to filter 

sigRes <- revigo_input[as.numeric(revigo_input$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes, file = "topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```





















